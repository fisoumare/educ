<!DOCTYPE html>
<html>

<!-- Mirrored from docs.laravel.fr/dev/eloquent by HTTrack Website Copier/3.x [XR&CO'2013], Mon, 03 Mar 2014 17:12:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            L'ORM Eloquent - Documentation Laravel dev - Laravel France
    </title>

    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/font-awesome.min.css">
    <link rel="stylesheet" href="../css/app.css">
    </head>
<body class=" preload">

    
    
    <header>
        <nav>
            <h1 class="title">
                <a href="http://laravel.fr/"><img src="../img/laravel_logo.png" alt="Laravel logo"> Laravel France</a>
            </h1>
            <ul class="menu">
                <li class="toggle"><a href="javascript:void(0);"><i class="icon-reorder"></i> Menu</a></li>
                <li class='active'><a href="../index.html"><i class="icon-book"></i> Documentation</a></li>

                <li >
                    <a href="#"><i class="icon-group"></i> Communauté</a>
                    <ul>
                        <li ><a href="http://forums.laravel.fr/">Forums</a></li>
                        <li ><a href="http://wiki.laravel.fr/">Wiki</a></li>
                        <li ><a href="http://laravel.fr/irc">IRC</a></li>
                    </ul>
                </li>
                <li ><a href="http://laravel.fr/contact"><i class="icon-envelope"></i> Contact</a></li>
                                    <li class="account">
                        <a href="#"><i class="icon-user"></i> Connexion</a>
                        <ul>
                            <li><a href="http://laravel.fr/login/Google">Google</a></li>
                            <li><a href="http://laravel.fr/login/twitter">Twitter</a></li>
                            <li><a href="http://laravel.fr/login/GitHub">Github</a></li>
                        </ul>
                    </li>
                            </ul>
        </nav>
    </header>

    <div id="page">
        <div class="container" id="pageDoc">

    <div class="sidebar">
            <a href="#" onclick="toggleDocVersions(); return false;" class="btn-orange changeVersionLink">Changer de version</a>


    <ul id="doc-versions">
        <li><a rel="nofollow" href="../dev.html">Laravel Dev</a></li>
        <li><a rel="nofollow" href="../4.html">Laravel 4.1</a></li>
        <li><a rel="nofollow" href="../4-2.html">Laravel 4.0</a></li>
        <li><a rel="nofollow" href="../3.html">Laravel 3</a></li>
    </ul>

    <p><a name="preface"></a></p>

<h3>Préface</h3>

<ul>
<li><a href="introduction.html">Introduction</a></li>
<li><a href="quick.html">Démarrage rapide</a></li>
<li><a href="releases.html">Release Notes</a></li>
<li><a href="upgrade.html">Mise à jour</a>
<a name="premiers-pas"></a></li>
</ul>

<h3>Premiers pas</h3>

<ul>
<li><a href="installation.html">Installation</a></li>
<li><a href="configuration.html">Configuration</a></li>
<li><a href="lifecycle.html">Cycle de vie d'une requête</a></li>
<li><a href="routing.html">Le routage</a></li>
<li><a href="requests.html">Requêtes et entrées</a></li>
<li><a href="responses.html">Les vues et les réponses</a></li>
<li><a href="controllers.html">Les contrôleurs</a></li>
<li><a href="errors.html">Les erreurs et la journalisation</a>
<a name="aller-plus-loin"></a></li>
</ul>

<h3>Aller plus loin</h3>

<ul>
<li><a href="security.html">Identification</a></li>
<li><a href="cache.html">La gestion du cache</a></li>
<li><a href="events.html">Les événements</a></li>
<li><a href="extending.html">Étendre le Framework</a></li>
<li><a href="facades.html">Facades</a></li>
<li><a href="html.html">Formulaires &amp; HTML</a></li>
<li><a href="helpers.html">Helpers</a></li>
<li><a href="ioc.html">Le conteneur de dépendances</a></li>
<li><a href="localization.html">Traduction &amp; Localisation</a></li>
<li><a href="mail.html">Email</a></li>
<li><a href="packages.html">Développement de packages</a></li>
<li><a href="pagination.html">La pagination</a></li>
<li><a href="queues.html">Les files de travaux</a></li>
<li><a href="security.html">La sécurité</a></li>
<li><a href="session.html">Les sessions</a></li>
<li><a href="ssh.html">SSH</a></li>
<li><a href="templates.html">Les templates</a></li>
<li><a href="testing.html">Les tests unitaires</a></li>
<li><a href="validation.html">La validation</a>
<a name="base-de-donnees"></a></li>
</ul>

<h3>Base de données</h3>

<ul>
<li><a href="database.html">Les bases de données</a></li>
<li><a href="queries.html">Query Builder</a></li>
<li><a href="eloquent.html">L'ORM Eloquent</a></li>
<li><a href="schema.html">Le constructeur de schéma</a></li>
<li><a href="migrations.html">Les migrations et la population</a></li>
<li><a href="redis.html">Redis</a>
<a name="artisan-cli"></a></li>
</ul>

<h3>Artisan CLI</h3>

<ul>
<li><a href="artisan.html">Présentation</a></li>
<li><a href="commands.html">Développement de commandes</a></li>
</ul>
    </div>

    <div class="documentationContent">
            <h1>Eloquent ORM</h1>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#basic-usage">Utilisation basique</a></li>
<li><a href="#mass-assignment">Assignement de masse</a></li>
<li><a href="#insert-update-delete">Insertion, mise à jour, suppression</a></li>
<li><a href="#soft-deleting">Suppression douce</a></li>
<li><a href="#timestamps">Timestamps</a></li>
<li><a href="#query-scopes">Cadres de requête</a></li>
<li><a href="#relationships">Relations</a></li>
<li><a href="#querying-relations">Requêtes sur les relations</a></li>
<li><a href="#eager-loading">Chargements liés</a></li>
<li><a href="#inserting-related-models">Insertion de modèles liés</a></li>
<li><a href="#touching-parent-timestamps">Mise à jour du Timestamps des parents</a></li>
<li><a href="#working-with-pivot-tables">Travail sur les tables pivots</a></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#accessors-and-mutators">Les accesseurs et mutateurs</a></li>
<li><a href="#date-mutators">Mutateurs de date</a></li>
<li><a href="#model-events">Evénements de modèle</a></li>
<li><a href="#model-observers">Observateurs de modèle</a></li>
<li><a href="#converting-to-arrays-or-json">Conversion en tableau / JSON</a></li>
</ul>

<p><a name="introduction"></a></p>

<h2>Introduction</h2>

<p>L'ORM Eloquent inclus avec Laravel fournit une implémentation magnifique et simple d'ActiveRecord pour travailler avec votre base de données. Chaque table de votre base de données a un Modèle associé pour intéragir avec cette table.</p>

<p>Avant de commencer, n'oubliez pas de configurer votre connexion à la base de données dans le fichier <code>app/config/database.php</code>.</p>

<p><a name="basic-usage"></a></p>

<h2>Utilisation basique</h2>

<p>Pour commencer, créez un modèle Eloquent. Ils sont généralement stockés dans le dossier <code>app/models</code>, mais vous êtes libre de les mettre dans n'importe quel endroit qui peut être chargé automatiquement en accord avec votre fichier <code>composer.json</code>.</p>

<h4>Définition d'un modèle Eloquent</h4>

<pre><code>class User extends Eloquent {}
</code></pre>

<p>Notez que nous n'avons pas indiqué à Eloquent quelle table doit être utilisée pour notre modèle <code>User</code>. Le nom de la classe en minuscule et au pluriel sera utilisé en tant que table à moins que vous ne définissiez une autre table explicitement. Donc dans ce cas, Eloquent utilisera le table <code>users</code> pour le modèle <code>User</code>. Pour définir explicitement un nom de table, définissez une propriété <code>$table</code> dans votre modèle :</p>

<pre><code>class User extends Eloquent {

    protected $table = 'my_users';

}
</code></pre>

<p>Eloquent va également présumer que votre table a une clé primaire nommée <code>id</code>. Vous pouvez définir une propriété <code>primaryKey</code> pour surcharger cette convention. De la même manière, vous pouvez définir une propriété <code>connection</code> pour surcharger le nom de la connexion qui sera utilisé pour accéder à la table de ce modèle.</p>

<p>Une fois qu'un modèle est défini, vous êtes prêt à récupérer et à créer des enregistrements dans votre table. Notez que vous aurez besoin de créer des colonnes <code>updated_at</code> et <code>created_at</code> sur votre table par défaut. Si vous ne voulez pas de ces colonnes, qui sont auto-maintenues par Laravel, définissez une propriété <code>$timestamps</code> à <code>false</code>.</p>

<h4>Retourne tous les modèles</h4>

<pre><code>$users = User::all();
</code></pre>

<h4>Retourne un modèle par sa clé primaire</h4>

<pre><code>$user = User::find(1);

var_dump($user-&gt;name);
</code></pre>

<blockquote>
  <p><strong>Note:</strong> Toutes les méthodes disponibles dans le <a href="queries.html">Query Builder</a> sont également disponibles avec Eloquent.</p>
</blockquote>

<h4>Récupérer un modèle par sa clé primaire ou lancer une exception</h4>

<p>Parfois vous pourriez vouloir lancer une exception si un modèle n'est pas trouvé, vous permettant d'attraper les exceptions en utilisant un gestionnaire d'événement <code>error</code> et afficher une page 404.</p>

<pre><code>$model = User::findOrFail(1);

$model = User::where('votes', '&gt;', 100)-&gt;firstOrFail();
</code></pre>

<p>Pour enregistrer le gestionnaire d'erreur, écoutez auprès d'un <code>ModelNotFoundException</code></p>

<pre><code>use Illuminate\Database\Eloquent\ModelNotFoundException;

App::error(function(ModelNotFoundException $e)
{
    return Response::make('Not Found', 404);
});
</code></pre>

<h4>Requêtage utilisant le modèle Eloquent</h4>

<pre><code>$users = User::where('votes', '&gt;', 100)-&gt;take(10)-&gt;get();

foreach ($users as $user) {
    var_dump($user-&gt;name);
}
</code></pre>

<p>Bien sûr, vous pouvez également utiliser les fonctions d'agrégat du Query Builder.</p>

<h4>Agrégat avec Eloquent</h4>

<pre><code>$count = User::where('votes', '&gt;', 100)-&gt;count();
</code></pre>

<p>Si vous êtes dans l'impossibilité de générer la requête que vous souhaitez via l'interface Fluent, alors n'hésitez pas à utiliser la méthode <code>whereRaw</code>:</p>

<p>$users = User::whereRaw('age > ? and votes = 100', array(25))->get();</p>

<h4>Ségmentation des résultats</h4>

<p>Si vous avez besoin de traiter beaucoup (des milliesr) d'enregistrements Eloquent, utiliser la méthode <code>chunk</code> vous permettra d'économiser beaucoup de RAM :</p>

<pre><code>User::chunk(200, function($users)
{
    foreach ($users as $user)
    {
        //
    }
});
</code></pre>

<p>Le premier argument est le nom de lignes que vous souhaitez recevoir par ségment, La fonction anonyme passée en second argument sera appelée pour chaque ségment provenant de la base de données.</p>

<h4>Spécification de la connexion</h4>

<p>Vous pouvez spécifier quelle connexion à la base de données est utilisée quand vous lancez une requête Eloquent. Utilisez simplement la méthode <code>on</code> :</p>

<pre><code>$user = User::on('connection-name')-&gt;find(1);
</code></pre>

<p><a name="mass-assignment"></a></p>

<h2>Assignement de masse</h2>

<p>Lorsque vous créez un nouveau modèle, vous passez un tableau d'attributs au constructeur du modèle. Ces attributs sont ensuite assignés au modèle via l'assignement de masse. C'est très pratique, cependant cela peut être un risque <strong>sérieux</strong> de sécurité lorsque des données provenant d'utilisateurs sont aveuglément passées dans un modèle. Dans ce cas, l'utilisateur est libre de modifier n'importe quel attribut du modèle.</p>

<p>Pour commencer, définissez les propriétés <code>fillable</code> ou <code>guarded</code> sur votre modèle.</p>

<p>La propriété <code>fillable</code> spécifie quels attributs peuvent être assignés en masse. Cela peut être défini dans la classe ou au niveau de l'instance du modèle.</p>

<h4>Définition de l'attribut fillable dans un modèle</h4>

<pre><code>class User extends Eloquent {

    protected $fillable = array('first_name', 'last_name', 'email');

}
</code></pre>

<p>Dans cet exemple, seuls les trois attributs listés peuvent être assignés lors d'un assignement de masse.</p>

<p>L'inverse de <code>fillable</code> est <code>guarded</code>, et il contient une "blacklist" plutôt qu'un laisser passer :</p>

<h4>Définition de l'attribut guarded dans un modèle</h4>

<pre><code>class User extends Eloquent {

    protected $guarded = array('id', 'password');

}
</code></pre>

<p>Dans l'exemple ci-dessus, les attributs <code>id</code> et <code>password</code> <strong>ne peuvent pas</strong> être assignés en masse. Tous les autres attributs peuvent être assignés lors d'un assignement de masse.  Vous pouvez aussi bloquer <strong>tous</strong> les attributs lors de l'assignement de masse en utilisant guard :</p>

<h4>Bloque tous les attributs lors de l'assignement de masse</h4>

<pre><code>protected $guarded = array('*');
</code></pre>

<p><a name="insert-update-delete"></a></p>

<h2>Insertion, mise à jour, suppression</h2>

<p>Pour créer un nouvel enregistrement dans la base de données pour un modèle, créez simplement une nouvelle instance d'un modèle et appelez la méthode <code>save</code>.</p>

<h4>Sauvegarde un nouveau modèle</h4>

<pre><code>$user = new User;

$user-&gt;name = 'John';

$user-&gt;save();
</code></pre>

<blockquote>
  <p><strong>Note:</strong> Typiquement, votre modèle Eloquent aura une clé de type auto-increment. Cependant, si vous souhaitez spécifier votre propre clé, définissez la propriété <code>incrementing</code> de votre modèle à <code>false</code>.</p>
</blockquote>

<p>Vous pouvez également utiliser la méthode <code>create</code> pour sauvegarder un modèle en une seule ligne. L'instance du modèle inséré sera retournée par la méthode. Cependant avant de faire cela, vous devrez spécifier l'attribut <code>fillable</code> ou <code>guarded</code> sur le modèle, car tous les modèles Eloquent sont protégés contre l'assignement de masse.</p>

<p>Après avoir sauvé ou créé un nouveau modèle qui utilise un ID auto-incrémental, vous pouvez retrouver l'ID en accédant à l'attribut <code>id</code> de l'objet.</p>

<h4>Mise en place de l'attribut guarded sur le modèle</h4>

<pre><code>class User extends Eloquent {

    protected $guarded = array('id', 'account_id');

}
</code></pre>

<h4>Création d'un utilisateur en utilisant la méthode create</h4>

<pre><code>// Create a new user in the database...
$user = User::create(array('name' =&gt; 'John'));

// Retrieve the user by the attributes, or create it if it doesn't exist...
$user = User::firstOrCreate(array('name' =&gt; 'John'));

// Retrieve the user by the attributes, or instantiate a new instance...
$user = User::firstOrNew(array('name' =&gt; 'John'));
</code></pre>

<p>Pour mettre à jour un modèle, récupérez le, changez un attribut, et utilisez la méthode <code>save</code> :</p>

<h4>Mise à jour d'un Modèle</h4>

<pre><code>$user = User::find(1);

$user-&gt;email = 'john@foo.com';

$user-&gt;save();
</code></pre>

<p>Parfois vous pourriez vouloir sauvegarder non seulement le modèle, mais aussi toutes ses relations. Pour ce faire, utilisez la méthode <code>push</code> :</p>

<h4>Sauvegarde un modèle et ses relations</h4>

<pre><code>$user-&gt;push();
</code></pre>

<p>Vous pouvez aussi lancer une mise à jour sur un ensemble de modèles :</p>

<pre><code>$affectedRows = User::where('votes', '&gt;', 100)-&gt;update(array('status' =&gt; 2));
</code></pre>

<p>Pour supprimer un modèle, appelez simplement la méthode <code>delete</code> sur une instance :</p>

<h4>Suppression d'un modèle existant</h4>

<pre><code>$user = User::find(1);

$user-&gt;delete();
</code></pre>

<h4>Suppression de modèles par leur clé</h4>

<pre><code>User::destroy(1);

User::destroy(array(1, 2, 3));

User::destroy(1, 2, 3);
</code></pre>

<p>Bien sûr, vous pouvez également supprimer un ensemble de modèles :</p>

<pre><code>$affectedRows = User::where('votes', '&gt;', 100)-&gt;delete();
</code></pre>

<p>Si vous souhaitez simplement mettre à jour les timestamps d'un modèle, utilisez la méthode <code>touch</code> :</p>

<h4>Mise à jour uniquement des timestamps d'un modèle</h4>

<pre><code>$user-&gt;touch();
</code></pre>

<p><a name="soft-deleting"></a></p>

<h2>Suppression douce</h2>

<p>Lors de la suppression douce d'un modèle, il n'est en fait pas vraiment supprimé de votre base de données. A la place, un timestamp <code>deleted_at</code> est défini sur la ligne. Pour activer la suppression douce sur un modèle, ajoutez la propriété <code>softDelete</code> à ce dernier :</p>

<pre><code>class User extends Eloquent {

    protected $softDelete = true;

}
</code></pre>

<p>Pour ajouter une colonne <code>deleted_at</code> à votre table, vous pouvez utiliser la méthode <code>softDeletes</code> depuis une migration:</p>

<pre><code>$table-&gt;softDeletes();
</code></pre>

<p>Maintenant, lorsque vous appellez la méthode <code>delete</code> sur le modèle, la colonne <code>deleted_at</code> sera remplie avec la date et l'heure de suppression. Lorsque vous requêtez un modèle avec de la suppression douce, les modèles "supprimés" ne seront pas inclus dans le résultat. Pour forcer l'apparition des modèles réputés supprimés, utilisez la méthode <code>withTrashed</code> sur la requête :</p>

<h4>Force l'affichage des lignes réputées supprimées</h4>

<pre><code>$users = User::withTrashed()-&gt;where('account_id', 1)-&gt;get();
</code></pre>

<p>Si vous souhaitez recevoir <strong>uniquement</strong> les lignes supprimées, utilisez la méthode <code>onlyTrashed</code> :</p>

<pre><code>$users = User::onlyTrashed()-&gt;where('account_id', 1)-&gt;get();
</code></pre>

<p>Pour annuler cette suppression, utilisez la méthode <code>restore</code> :</p>

<pre><code>$user-&gt;restore();
</code></pre>

<p>Vous pouvez également utiliser la méthode <code>restore</code> sur une requête :</p>

<pre><code>User::withTrashed()-&gt;where('account_id', 1)-&gt;restore();
</code></pre>

<p>La méthode <code>restore</code> peut également être utilisée sur une relation :</p>

<pre><code>$user-&gt;posts()-&gt;restore();
</code></pre>

<p>Si vous souhaitez réellement supprimer une ligne de la base de données, vous pouvez utiliser la méthode <code>forceDelete</code> :</p>

<pre><code>$user-&gt;forceDelete();
</code></pre>

<p>La méthode <code>forceDelete</code> marche également sur les relations :</p>

<pre><code>$user-&gt;posts()-&gt;forceDelete();
</code></pre>

<p>Pour déterminer si un modèle donné a été supprimé de manière douce, vous pouvez utiliser la méthode <code>trashed</code> :</p>

<pre><code>if ($user-&gt;trashed()) {
    //
}
</code></pre>

<p><a name="timestamps"></a></p>

<h2>Timestamps</h2>

<p>Par défaut, Eloquent maintiendra les colonnes <code>created_at</code> et <code>updated_at</code> de votre table automatiquement. Ajoutez simplement ces colonnes de type <code>timestamp</code> à votre table et Eloquent va automatiquement se charger du reste. Si vous ne souhaitez pas qu'Eloquent s'en occupe, ajoutez la propriété suivante au modèle :</p>

<h4>Désactivation de l'auto-timestamps</h4>

<pre><code>class User extends Eloquent {

    protected $table = 'users';

    public $timestamps = false;

}
</code></pre>

<p>Si vous souhaitez personnaliser le format de vos timestamps, surchargez la méthode <code>getDateFormat</code> de votre modèle :</p>

<h4>Création d'un format de timestamp personnalisé pour ce modèle</h4>

<pre><code>class User extends Eloquent {

    protected function getDateFormat()
    {
        return 'U';
    }

}
</code></pre>

<p><a name="query-scopes"></a></p>

<h2>Cadres de requête</h2>

<p>Les cadres vous permettent de réutiliser facilement des logiques de requêtes dans vos modèles. Pour définir un cadre, préfixez simplement une méthode du modèle avec <code>scope</code>:</p>

<h4>Définition d'un cadre de requête</h4>

<pre><code>class User extends Eloquent {

    public function scopePopular($query)
    {
       return $query-&gt;where('votes', '&gt;', 100);
    }

    public function scopeWomen($query)
    {
        return $query-&gt;whereGender('W');
    }
}
</code></pre>

<h4>Utilisation d'un cadre de requête</h4>

<pre><code>$users = User::popular()-&gt;women()-&gt;orderBy('created_at')-&gt;get();
</code></pre>

<h4>Cadres dynamiques</h4>

<p>Des fois, vous pouvez vouloir définir un cadre qui accepte des paramètres. Ajoutez juste vos paramètres dans la fonction de cadre :</p>

<pre><code>class User extends Eloquent {

    public function scopeOfType($query, $type)
    {
        return $query-&gt;whereType($type);
    }

}
</code></pre>

<p>Passez ensuite le paramètre dans l'appel du cadre :</p>

<pre><code>$users = User::ofType('member')-&gt;get();
</code></pre>

<p><a name="relationships"></a></p>

<h2>Relations</h2>

<p>Bien sûr, vos tables sont probablement liées les unes aux autres. Par exemple, un post de blog a plusieurs commentaires, ou une commande est liée à l'utilisateur qui l'a passée. Eloquent rend la gestion et le travail avec ces relations simples. Laravel supporte quatre types de relation :</p>

<ul>
<li><a href="#one-to-one">Un vers un (1:1)</a></li>
<li><a href="#one-to-many">Un vers plusieurs (1:n)</a></li>
<li><a href="#many-to-many">Plusieurs vers plusieurs (n:n)</a></li>
<li><a href="#has-many-through">Plusieurs via</a></li>
<li><a href="#polymorphic-relations">Relations polymorphiques</a></li>
</ul>

<p><a name="one-to-one"></a></p>

<h3>Un vers un (1:1)</h3>

<p>Une relation un-vers-un est une relation très basique. Par exemple, un modèle <code>User</code> peut avoir un téléphone modèle <code>Phone</code>. Nous définissons la relation de la manière suivante avec Eloquent :</p>

<h4>Définition d'une relation un vers un</h4>

<pre><code>class User extends Eloquent {

    public function phone()
    {
        return $this-&gt;hasOne('Phone');
    }

}
</code></pre>

<p>Le premier argument passé à la méthode <code>hasOne</code> est le nom du modèle lié. Une fois que la relation est définie, nous pouvons la récupérer en utilisant les <a href="#dynamic-properties">propriétés dynamiques</a> d'Eloquent :</p>

<pre><code>$phone = User::find(1)-&gt;phone;
</code></pre>

<p>La requête SQL exécutée pour cette requête sera la suivante :</p>

<pre><code>select * from users where id = 1

select * from phones where user_id = 1
</code></pre>

<p>Notez qu'Eloquent devine la clé étrangère en se basant sur le nom du modèle. Dans ce cas, le modèle <code>Phone</code> doit avoir une colonne <code>user_id</code> en tant que clé étrangère. Vous pouvez surcharger cette convention en passant un second argument à la méthode <code>hasOne</code>. De plus, vous pouvez un troisième argument à la méthode pour spécifier quelle colonne locale doit être utilisée pour l'association :</p>

<pre><code>return $this-&gt;hasOne('Phone', 'foreign_key');

return $this-&gt;hasOne('Phone', 'foreign_key', 'local_key'););
</code></pre>

<h4>Définition de la relation inverse</h4>

<p>Pour définir la relation inverse sur le modèle <code>Phone</code>, nous utilisons la méthode <code>belongsTo</code> :</p>

<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User');
    }

}
</code></pre>

<p>Dans l'exemple ci dessus, Eloquent recherchera une colonne <code>user_id</code> sur la table <code>phones</code>. Si vous souhaitez définir un autre nom pour votre clé étrangère, vous pouvez le passer en tant que second argument de la méthode <code>belongsTo</code> :</p>

<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User', 'local_key');
    }

}
</code></pre>

<p>Additionnellement, vous pouvez passer un troisième paramètre qui spécifie le nom de la colonne associée dans la table parent :</p>

<p>class Phone extends Eloquent {</p>

<pre><code>public function user()
{
  return $this-&gt;belongsTo('User', 'local_key', 'parent_key');
}
</code></pre>

<p>}</p>

<p><a name="one-to-many"></a></p>

<h3>Un vers plusieurs (1:n)</h3>

<p>Un exemple de relation un-vers-plusieurs est un post de blog qui a plusieurs commentaires. Nous réalisons cette relation comme cela :</p>

<pre><code>class Post extends Eloquent {

    public function comments()
    {
        return $this-&gt;hasMany('Comment');
    }

}
</code></pre>

<p>Nous pouvons accéder aux commentaires du post via la <a href="#dynamic-properties">propriété dynamique</a> :</p>

<pre><code>$comments = Post::find(1)-&gt;comments;
</code></pre>

<p>Si vous avez besoin d'ajouter des contraintes supplémentaires à la récupération de 'comments', appelez la méthode <code>comments</code> et continuez à chainer les conditions :</p>

<pre><code>$comments = Post::find(1)-&gt;comments()-&gt;where('title', '=', 'foo')-&gt;first();
</code></pre>

<p>Une fois encore, vous pouvez surcharger le nom de la clé étrangère en passant en tant que second argument son nom à la méthode <code>hasMany</code>. Et, comme pour la relation <code>hasOne</code>, la colonne locale peut également être spécifiée  :</p>

<pre><code>return $this-&gt;hasMany('Comment', 'foreign_key');

return $this-&gt;hasMany('Comment', 'foreign_key', 'local_key');
</code></pre>

<p>Pour définir la relation inverse, sur le modèle <code>Comment</code>, nous utilisons la méthode <code>belongsTo</code> :</p>

<h4>Définition de la relation inverse</h4>

<pre><code>class Comment extends Eloquent {

    public function post()
    {
        return $this-&gt;belongsTo('Post');
    }

}
</code></pre>

<p><a name="many-to-many"></a></p>

<h3>Plusieurs vers plusieurs (n:n)</h3>

<p>Les relations plusieurs-vers-plusieurs sont un type un peu plus compliqué. Par exemple un utilisateur peut avoir plusieurs rôles, et un rôle peut être assigné à plusieurs utilisateurs. Plusieurs utilisateurs peuvent avoir un rôle "Admin" par exemple. Pour établir cette relation, nous avons besoin de trois tables : <code>users</code>, <code>roles</code>, et <code>role_user</code>. La table <code>role_user</code> est dérivée de l'ordre alphabétique des modèles liés, et doit contenir les colonnes <code>user_id</code> et <code>role_id</code>.</p>

<p>Nous pouvons définir une relation de type plusieurs-vers-plusieurs en utilisant la méthode <code>belongsToMany</code> :</p>

<pre><code>class User extends Eloquent {

    public function roles()
    {
        return $this-&gt;belongsToMany('Role');
    }

}
</code></pre>

<p>Maintenant nous pouvons récupérer nos rôles via le modèle <code>User</code> :</p>

<pre><code>$roles = User::find(1)-&gt;roles;
</code></pre>

<p>Si vous souhaitez utiliser un nom non conventionnel pour votre table pivot, passez le second argument de la méthode <code>belongsToMany</code> :</p>

<pre><code>return $this-&gt;belongsToMany('Role', 'user_roles');
</code></pre>

<p>Vous pouvez également surcharger les clés associées :</p>

<pre><code>return $this-&gt;belongsToMany('Role', 'user_roles', 'user_id', 'foo_id');
</code></pre>

<p>Bien sûr, vous pouvez aussi avoir besoin de définir de la relation dans le modèle <code>Role</code> :</p>

<pre><code>class Role extends Eloquent {

    public function users()
    {
        return $this-&gt;belongsToMany('User');
    }

}
</code></pre>

<p><a name="has-many-through"></a></p>

<h3>Plusieurs via</h3>

<p>La relation "plusieurs via" fournit un raccourci pratique pour accéder à une relation distante via une relation intermédiaire. Par exemple, un modèle <code>Country</code> peut avoir plusieurs <code>Posts</code> via un modèle <code>Users</code>. Les tables pour cette relation ressemble à cela :</p>

<pre><code>countries
  id - integer
  name - string

users
  id - integer
  country_id - integer
  name - string

posts
  id - integer
  user_id - integer
  title - string
</code></pre>

<p>Même si la table <code>posts</code> le contient pas une colonne <code>country_id</code>, la relation <code>hasManyThrough</code> ne donne la possibilité d'accéder aux posts d'un pays via <code>$country-&gt;posts</code>. Définissons la relation :</p>

<pre><code>class Country extends Eloquent {

    public function posts()
    {
        return $this-&gt;hasManyThrough('Post', 'User');
    }

}
</code></pre>

<p>Si vous souhaitez définir manuellement les clés de la relation, vous pouvez le faire grâce au troisième et au quatrième argument de la méthode :</p>

<pre><code>class Country extends Eloquent {

    public function posts()
    {
        return $this-&gt;hasManyThrough('Post', 'User', 'country_id', 'user_id');
    }

}
</code></pre>

<p><a name="polymorphic-relations"></a></p>

<h3>Relations polymorphiques</h3>

<p>Les relations polymorphiques permettent à un modèle d'appartenir à plus d'un autre modèle, en une simple association. Par exemple, vous pourriez avoir un modèle Photo qui appartient au modèle Staff ainsi qu'au modèle Commande. Nous définirons cette relation de la manière suivante :</p>

<pre><code>class Photo extends Eloquent {

    public function imageable()
    {
        return $this-&gt;morphTo();
    }

}

class Staff extends Eloquent {

    public function photos()
    {
        return $this-&gt;morphMany('Photo', 'imageable');
    }

}

class Commande extends Eloquent {

    public function photos()
    {
        return $this-&gt;morphMany('Photo', 'imageable');
    }

}
</code></pre>

<p>Maintenant, nous pouvons récupérer les photos soit de notre staff, soit d'une commande :</p>

<h4>Récupération d'une relation polymorphique</h4>

<pre><code>$staff = Staff::find(1);

foreach ($staff-&gt;photos as $photo) {
    //
}
</code></pre>

<h4>Récupération du propriétaire de la Photo</h4>

<p>Cependant, la vraie magie de la polymorphie apparait lorsque vous accédez au staff ou à la commande depuis le modèle <code>Photo</code> :</p>

<pre><code>$photo = Photo::find(1);

$imageable = $photo-&gt;imageable;
</code></pre>

<p>La relation <code>imageable</code> du modèle <code>Photo</code> retournera soit une instance de <code>Staff</code> ou de <code>Commande</code>, selon le modèle propriétaire de la photo.</p>

<p>Pour vous aider à comprendre comment cela marche, jetons un oeil à la structure de la base de données pour une relation polymorphique :</p>

<h4>Structure de la base de données pour une relation polymorphique</h4>

<pre><code>staff
    id - integer
    name - string

orders
    id - integer
    price - integer

photos
    id - integer
    path - string
    imageable_id - integer
    imageable_type - string
</code></pre>

<p>Les champs clés à remarquer ici sont <code>imageable_id</code> et <code>imageable_type</code> de la table <code>photos</code>. L'ID contiendra la valeur de l'ID d'une ligne de staff ou de commande ici par exemple, tandis que le type contiendra le nom de la classe du modèle propriétaire. C'est ce qui permet à l'ORM de déterminer quel type de propriétaire doit être retourné lors de l'accès à la relation <code>imageable</code>.</p>

<p><a name="querying-relations"></a></p>

<h2>Requêtes sur les relations</h2>

<p>Lorsque vous accédez aux lignes d'un modèle, vous pourriez vouloir limiter vos résultats en se basant sur l'existence d'une relation. Par exemple, pour récupérer les billets d'un blog qui ont au moins un commentaire. Pour ce faire, vous pouvez utiliser la méthode <code>has</code> :</p>

<h4>Requête d'une relation lors de la sélection</h4>

<pre><code>$posts = Post::has('comments')-&gt;get();
</code></pre>

<p>Vous pouvez également spécifier un opérateur et un nombre :</p>

<pre><code>$posts = Post::has('comments', '&gt;=', 3)-&gt;get();
</code></pre>

<p>Si vous voulez encore plus de puissance, vous pouvez utiliser <code>whereHas</code> et <code>orWhereHas</code> pour placer une condition "where" sur une requête <code>has</code> :</p>

<pre><code>$posts = Post::whereHas('comments', function($q)
{
    $q-&gt;where('content', 'like', 'foo%');
})-&gt;get();
</code></pre>

<p><a name="dynamic-properties"></a></p>

<h3>Propriétés dynamiques</h3>

<p>Eloquent vous autorise à accéder à vos relations par des propriétés dynamiques. Eloquent va automatiquement charger la relation pour vous, et est assez malin pour savoir quand appeler la méthode <code>get</code> (pour les relations one-to-many) ou <code>first</code> (pour les relations one-to-one). La relation sera alors accessible par une propriété dynamique qui porte le même nom que la relation. Par exemple, avec le modèle <code>$phone</code>:</p>

<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User');
    }

}

$phone = Phone::find(1);
</code></pre>

<p>Plutôt que d'afficher l'adresse e-mail de l'utilisateur ainsi :</p>

<pre><code>echo $phone-&gt;user()-&gt;first()-&gt;email;
</code></pre>

<p>L'appel peut se faire de cette manière :</p>

<pre><code>echo $phone-&gt;user-&gt;email;
</code></pre>

<blockquote>
  <p><strong>Note:</strong> les relations retournant plusieurs résultats retourneront une instance de la classe <code>Illuminate\Database\Eloquent\Collection</code>.</p>
</blockquote>

<p><a name="eager-loading"></a></p>

<h2>Chargements liés</h2>

<p>Les chargements liés (eager loading) existent pour éviter le problème des requêtes N + 1. Par exemple, disons qu'un modèle <code>Book</code> est relié à un modèle <code>Author</code>. La relation est définie de la manière suivante :</p>

<pre><code>class Book extends Eloquent {

    public function author()
    {
        return $this-&gt;belongsTo('Author');
    }

}
</code></pre>

<p>Maintenant considérez le code suivant :</p>

<pre><code>foreach (Book::all() as $book) {
    echo $book-&gt;author-&gt;name;
}
</code></pre>

<p>La boucle exécutera une requête pour récupérer tous les livres de la table, ensuite une autre requête sur chaque livre pour récupérer l'auteur. Donc, si nous avons 25 livres, nous aurons 26 requêtes.</p>

<p>Heureusement, nous pouvons utiliser les chargements liés pour réduire drastiquement le nombre de requêtes. Les relations qui doivent être chargées doivent être précisées avec la méthode <code>with</code> :</p>

<pre><code>foreach (Book::with('author')-&gt;get() as $book) {
    echo $book-&gt;author-&gt;name;
}
</code></pre>

<p>Pour la boucle ci-dessus, les requêtes suivantes sont exécutées :</p>

<pre><code>select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)
</code></pre>

<p>Une utilisation sage des chargements liés peut augmenter drastiquement les performances de votre application.</p>

<p>Bien sûr, vous pouvez faire des chargements liés sur plusieurs relations en une fois :</p>

<pre><code>$books = Book::with('author', 'publisher')-&gt;get();
</code></pre>

<p>Vous pouvez même faire du chargement lié de manière imbriquée :</p>

<pre><code>$books = Book::with('author.contacts')-&gt;get();
</code></pre>

<p>Dans l'exemple ci-dessus, la relation <code>author</code> sera chargée de manière liée, et les contacts de l'auteur seront chargés également.</p>

<h3>Contraintes sur les chargements liés</h3>

<p>Si vous avez besoin d'ajouter des contraintes sur un chargement lié, vous pouvez le faire de la manière suivante :</p>

<pre><code>$users = User::with(array('posts' =&gt; function($query)
{
    $query-&gt;where('title', 'like', '%first%');
}))-&gt;get();
</code></pre>

<p>Dans cet exemple, nous chargeons les posts de l'utilisateur, mais seulement si le post contient le mot "first".</p>

<h3>Chargements liés différés</h3>

<p>Il est également possible de faire du chargement lié directement sur une collection de modèles existants. Cela peut s'avérer utile si vous devez décider dynamiquement de charger les modèles liés ou non, ou en combinaison avec du cache.</p>

<pre><code>$books = Book::all();

$books-&gt;load('author', 'publisher');
</code></pre>

<p><a name="inserting-related-models"></a></p>

<h2>Insertion de modèles liés</h2>

<p>Vous aurez souvent besoin d'insérer des nouveaux modèles liés. Par exemple, pour insérer un commentaire lié à un post de blog, plutôt que de définir manuellement la clé étrangère <code>post_id</code> sur le modèle, vous pouvez insérer un nouveau commentaire directement depuis son modèle parent <code>Post</code> :</p>

<h4>Attachement à un modèle lié</h4>

<pre><code>$comment = new Comment(array('message' =&gt; 'A new comment.'));

$post = Post::find(1);

$comment = $post-&gt;comments()-&gt;save($comment);
</code></pre>

<p>Dans cet exemple, le champ <code>post_id</code> sera automatiquement rempli dans le commentaire inséré.</p>

<h3>Associations de modèles (Belongs To)</h3>

<p>Lors de la mise à jour d'une relation <code>belongsTo</code>, vous pouvez utiliser la méthode <code>associate</code>. Cette méthode renseigne la clé étrangère dans le modèle enfant :</p>

<pre><code>$account = Account::find(10);

$user-&gt;account()-&gt;associate($account);

$user-&gt;save();
</code></pre>

<h3>Insertion de modèles liés, plusieurs vers plusieurs</h3>

<p>Vous devrez également insérer des modèles liés par une relation <code>plusieurs vers plusieurs</code>. Continuons d'utiliser nos modèles d'exemples <code>User</code> et <code>Role</code>. Nous pouvons facilement attacher des nouveaux rôles à un utilisateur avec la méthode :</p>

<h4>Attache des modèles liés par une relation plusieurs vers plusieurs</h4>

<pre><code>$user = User::find(1);

$user-&gt;roles()-&gt;attach(1);
</code></pre>

<p>Vous pouvez également passer un tableau d'attributs qui doivent être stockés dans la table pivot pour la relation :</p>

<pre><code>$user-&gt;roles()-&gt;attach(1, array('expires' =&gt; $expires));
</code></pre>

<p>Naturellement, l'opposé de <code>attach</code> est <code>detach</code> :</p>

<pre><code>$user-&gt;roles()-&gt;detach(1);
</code></pre>

<p>Vous pouvez également utiliser la méthode <code>sync</code> pour attacher des modèles liés. La méthode <code>sync</code> accepte un tableau d'IDs à placer dans la table pivot. Une fois cette opération terminée, seuls les IDs dans le tableau seront dans la table pivot pour le modèle :</p>

<h4>Utilisation de la méthode Sync pour attacher des modèles liés</h4>

<pre><code>$user-&gt;roles()-&gt;sync(array(1, 2, 3));
</code></pre>

<p>Vous pouvez également créer un nouveau modèle lié et l'attacher en une simple ligne. Pour cette opération, utilisez la méthode <code>save</code> :</p>

<pre><code>$role = new Role(array('name' =&gt; 'Editor'));

User::find(1)-&gt;roles()-&gt;save($role);
</code></pre>

<p>Dans cet exemple, le nouveau modèle <code>Role</code> sera sauvegardé et attaché au modèle <code>User</code>. Vous pourriez également avoir besoin de passer un tableau d'attributs pour le sauvegarder dans la table de jointure :</p>

<pre><code>User::find(1)-&gt;roles()-&gt;save($role, array('expires' =&gt; $expires));
</code></pre>

<p><a name="touching-parent-timestamps"></a></p>

<h2>Mise à jour du Timestamps des parents</h2>

<p>Quand un modèle appartient à (<code>belongsTo</code>) un autre modèle, comme un <code>Comment</code> appartient à un <code>Post</code>, il est souvent utile de mettre à jour les timestamps du parent lorsque le modèle enfant est mis à jour. Par exemple, lorsqu'un commentaire est modifié, nous pourrions mettre à jour le <code>Post</code> qui le contient. Eloquent rend cela facile. Ajoutez simplement la propriété <code>touches</code> qui contient le nom des relations dans le modèle enfant :</p>

<pre><code>class Comment extends Eloquent {

    protected $touches = array('post');

    public function post()
    {
        return $this-&gt;belongsTo('Post');
    }

}
</code></pre>

<p>Maintenant, quand vous mettrez à jour un <code>Comment</code>, le <code>Post</code> parent aura sa colonne <code>updated_at</code> mise à jour :</p>

<pre><code>$comment = Comment::find(1);

$comment-&gt;text = 'Edit to this comment!';

$comment-&gt;save();
</code></pre>

<p><a name="working-with-pivot-tables"></a></p>

<h2>Travail sur les tables pivots</h2>

<p>Comme vous l'avez déjà appris, le travail avec les relations plusieurs-vers-plusieurs nécessite la présence d'une table intermédiaire. Eloquent fournit des moyens très utiles d'interagir avec cette table. Par exemple, disons que nous avons un objet <code>User</code> qui a plusieurs objets <code>Role</code>. Après avoir accédé à la relation, vous pouvez accéder à la table <code>pivot</code> du modèle :</p>

<pre><code>$user = User::find(1);

foreach ($user-&gt;roles as $role) {
    echo $role-&gt;pivot-&gt;created_at;
}
</code></pre>

<p>Notez que chaque modèle <code>Role</code> que nous récupérons aura automatiquement l'attribut <code>pivot</code> assigné. Cet attribut contient un modèle qui représente la table intermédiaire, et peut être utilisé comme n'importe quel autre modèle Eloquent.</p>

<p>Par défaut, seules les clés seront présentes dans l'objet <code>pivot</code>. Si votre table pivot contient des attributs en plus, vous devez les spécifier lors de la définition de la relation :</p>

<pre><code>return $this-&gt;belongsToMany('Role')-&gt;withPivot('foo', 'bar');
</code></pre>

<p>Maintenant, les attributs <code>foo</code> et <code>bar</code> seront accessibles par l'objet <code>pivot</code> pour le modèle <code>Role</code>.</p>

<p>Si vous souhaitez que votre table pivot ait les timestamps <code>created_at</code> et <code>updated_at</code> automatiquement maintenus, utilisez la méthode <code>withTimestamps</code> sur la définition de la relation :</p>

<pre><code>return $this-&gt;belongsToMany('Role')-&gt;withTimestamps();
</code></pre>

<p>Pour supprimer toutes les lignes de la table pivot pour un modèle, vous pouvez utiliser la méthode <code>detach</code> :</p>

<h4>Suppression des lignes de la table pivot</h4>

<pre><code>User::find(1)-&gt;roles()-&gt;detach();
</code></pre>

<p>Notez que cette opération ne supprimera pas les enregistrements de la table <code>roles</code>, mais seulement de la table pivot.</p>

<h4>Définition d'un modèle de pivot personnalisé</h4>

<p>Laravel vous permet de définir votre propre modèle de pivot. Pour ce faire, créez votre propose modèle de "Base" qui étend <code>Eloquent</code>. Dans vos autres modèles Eloquent, héritez de cette "Base" plutôt que d'<code>Eloquent</code>. Dans votre modèle de "Base", Ajoutez la fonction suivante qui retourne une instance de de votre modèle de pivot personnalisé :</p>

<pre><code>public function newPivot(Model $parent, array $attributes, $table, $exists)
{
    return new YourCustomPivot($parent, $attributes, $table, $exists);
}
</code></pre>

<p><a name="collections"></a></p>

<h2>Collections</h2>

<p>Toutes les requêtes qui renvoient plusieurs résultats par Eloquent, via la méthode <code>get</code> ou par une relation, retournent un objet <code>Collection</code>. Cet objet implémente l'interface PHP <code>IteratorAggregate</code>, donc nous pouvons itérer dessus comme pour un tableau. Cependant, cet objet a également une variété de méthodes utiles pour travailler avec une liste de résultats.</p>

<p>Par exemple, nous pouvons déterminer si une liste de résultats contient une clé primaire donnée en utilisant la méthode <code>contains</code> :</p>

<h4>Vérifie si une collection contient une clé</h4>

<pre><code>$roles = User::find(1)-&gt;roles;

if ($roles-&gt;contains(2)) {
    //
}
</code></pre>

<p>Les Collections peuvent être converties en tableau ou en JSON :</p>

<pre><code>$roles = User::find(1)-&gt;roles-&gt;toArray();

$roles = User::find(1)-&gt;roles-&gt;toJson();
</code></pre>

<p>Si une collection est castée en une chaîne, alors sa représentation JSON sera retournée :</p>

<pre><code>$roles = (string) User::find(1)-&gt;roles;
</code></pre>

<p>Les collections Eloquent contiennent également quelques méthodes utiles pour boucler et filtrer sur les objets qu'elle contient :</p>

<h4>Bouclage de collections</h4>

<pre><code>$roles = $user-&gt;roles-&gt;each(function($role)
{

});
</code></pre>

<h4>Filtrage de collections</h4>

<p>Lors du filtrage de collections, le retour fourni sera utilisé comme retour pour <a href="http://php.net/manual/en/function.array-filter.php">array_filter</a>.</p>

<pre><code>$users = $users-&gt;filter(function($user)
{
    if ($user-&gt;isAdmin()) {
        return $user;
    }
});
</code></pre>

<blockquote>
  <p><strong>Note:</strong> lors du filtrage d'une collection et la conversion en JSON, essayez d'appeler les <code>valeurs</code> de la première fonction pour remettre à zéro les clés du tableau.</p>
</blockquote>

<h4>Applique une fonction sur chaque object d'une collection</h4>

<pre><code>$roles = User::find(1)-&gt;roles;

$roles-&gt;each(function($role)
{

});
</code></pre>

<h4>Tri une collection par une valeur</h4>

<pre><code>$roles = $roles-&gt;sortBy(function($role)
{
    return $role-&gt;created_at;
});
</code></pre>

<p>Parfois, vous pourriez vouloir retourner une collection personnalisée avec vos propres méthodes ajoutées. Vous devez spécifier cela dans votre modèle Eloquent en surchargeant la méthode <code>newCollection</code> :</p>

<h4>Retourne un type de collection personnalisé</h4>

<pre><code>class User extends Eloquent {

    public function newCollection(array $models = array())
    {
        return new CustomCollection($models);
    }

}
</code></pre>

<p><a name="accessors-and-mutators"></a></p>

<h2>Les accesseurs et mutateurs</h2>

<p>Eloquent fournit une manière efficace de transformer vos attributs de modèle lorsque vous les récupérez ou les définissez. Définissez simplement une méthode <code>getFooAttribute</code> sur votre modèle pour créer un accesseur. Gardez à l'esprit que les méthodes doivent être en camelCase, même si les colonnes de votre base sont en snake_case :</p>

<h4>Définition d'un accesseur</h4>

<pre><code>class User extends Eloquent {

    public function getFirstNameAttribute($value)
    {
        return ucfirst($value);
    }

}
</code></pre>

<p>Dans l'exemple ci-dessus, la colonne <code>first_name</code> a un accesseur. Notez que la valeur est passée à l'accesseur.</p>

<p>Les mutateurs sont déclarés dans le même esprit :</p>

<h4>Définition d'un mutateur</h4>

<pre><code>class User extends Eloquent {

    public function setFirstNameAttribute($value)
    {
        $this-&gt;attributes['first_name'] = strtolower($value);
    }

}
</code></pre>

<p><a name="date-mutators"></a></p>

<h2>Mutateurs de date</h2>

<p>Par défaut, Eloquent va convertir les colonnes <code>created_at</code>, <code>updated_at</code> et <code>deleted_at</code> en instance de <a href="https://github.com/briannesbitt/Carbon">Carbon</a>, qui fournit un lôt de méthodes utiles, et hérite de la classe PHP <code>DateTime</code>.</p>

<p>Vous pouvez personnaliser quels champs seront automatiquement mutés, voir même désactiver cette mutation, en surchargeant la méthode du modèle :</p>

<pre><code>public function getDates()
{
    return array('created_at');
}
</code></pre>

<p>Lorsqu'une colonne est considérée comme une date, vous pouvez définir sa valeur comme étant un timestamp UNIX, une chaîne de date (<code>Y-m-d</code>), une chaîne de type date et heure (<code>Y-m-d H:i:s</code>), ou bien sûr une instance de <code>DateTime</code> / <code>Carbon</code>.</p>

<p>Pour désactiver totalement la mutation des dates, retournez simplement un tableau vide depuis la méthode <code>getDates</code> :</p>

<pre><code>public function getDates()
{
    return array();
}
</code></pre>

<p><a name="model-events"></a></p>

<h2>Evénements de modèle</h2>

<p>Les modèles Eloquent lancent plusieurs événements, vous permettant d'interagir avec le modèle durant son cycle de vie en utilisant les méthodes : <code>creating</code> (avant la création), <code>created</code> (une fois créé), <code>updating</code> (avant la mise à jour), <code>updated</code> (une fois mis à jour), <code>saving</code> (avant l'enregistrement), <code>saved</code> (une fois enregistré), <code>deleting</code> (avant la suppression), <code>deleted</code> (une fois supprimé), <code>restoring</code> (avant la restauration), <code>restored</code> (une fois restauré).</p>

<p>Chaque fois qu'un nouvel item est sauvegardé pour la première fois, les événements <code>creating</code> et <code>created</code> sont lancés. Si un item n'est pas nouveau et que la méthode <code>save</code> est appelée, les événements <code>updating</code> / <code>updated</code> sont lancés. Dans les deux cas, les événements <code>saving</code> / <code>saved</code> sont lancés.</p>

<p>Si <code>false</code> est retourné par la méthode <code>creating</code>, <code>updating</code>, ou <code>saving</code>, alors l'action est annulée :</p>

<h4>Annulation de la création d'un modèle</h4>

<pre><code>User::creating(function($user)
{
    if ( ! $user-&gt;isValid()) return false;
});
</code></pre>

<p>Les modèles Eloquent contiennent également une méthode static <code>boot</code>, qui peut être l'endroit idéal pour s'abonner aux événements.</p>

<h4>Mise en place de la méthode boot d'un modèle</h4>

<pre><code>class User extends Eloquent {

    public static function boot()
    {
        parent::boot();

        // Setup event bindings...
  }

}
</code></pre>

<p><a name="model-observers"></a></p>

<h2>Observateurs de modèle</h2>

<p>Pour consolider le gestion des événements d'un modèle, vous pouvez enregistrer une observateur de modèle. Une classe d'observation peut avoir des méthodes qui correspondent à plusieurs événements d'un modèle. Par exemple, les méthodes <code>creating</code>, <code>updating</code>, <code>saving</code> peuvent être sur un observateur, en plus de n'importe quel autre nom d'événement de modèle.</p>

<p>Donc, par exemple, un observateur de modèle peut ressembler à cela :</p>

<pre><code>class UserObserver {

    public function saving($model)
    {
        //
    }

    public function saved($model)
    {
        //
    }

}
</code></pre>

<p>Vous pouvez enregistrer une instancve d'un observateur en utlisant la méthode <code>observe</code> :</p>

<pre><code>User::observe(new UserObserver);
</code></pre>

<p><a name="converting-to-arrays-or-json"></a></p>

<h2>Conversion en tableau / JSON</h2>

<p>Quand vous construisez des APIs en JSON, vous devez souvent convertir vos modèles et vos relations en tableau ou en JSON. Eloquent inclut des méthodes pour le faire. Pour convertir un modèle et ses relations en tableau, vous pouvez utiliser la méthode <code>toArray</code> :</p>

<h4>Convertion d'un modèle en tableau</h4>

<pre><code>$user = User::with('roles')-&gt;first();

return $user-&gt;toArray();
</code></pre>

<p>Notez que l'intégralité des collections de modèles peuvent être converties en tableau :</p>

<pre><code>return User::all()-&gt;toArray();
</code></pre>

<p>Pour convertir un modèle en JSON, vous pouvez utiliser la méthode <code>toJson</code> :</p>

<h4>Conversion d'un modèle en JSON</h4>

<pre><code>return User::find(1)-&gt;toJson();
</code></pre>

<p>Notez que quand un modèle ou une collection est casté en string, ils sont convertis en JSON, ce qui signifie que vous pouvez retourner des objets Eloquent directement depuis vos routes/actions !</p>

<h4>Retourne un modèle depuis une route</h4>

<pre><code>Route::get('users', function()
{
    return User::all();
});
</code></pre>

<p>Parfois vous pourriez souhaiter que certains attributs ne soient pas inclus dans la forme tableau ou JSON de vos modèles, tels que les mots de passes. Pour ce faire, ajoutez la propriété <code>hidden</code> à la définition de votre modèle :</p>

<h4>Cache un attribut des formats tableaux ou JSON</h4>

<pre><code>class User extends Eloquent {

    protected $hidden = array('password');

}
</code></pre>

<blockquote>
  <p><strong>Note:</strong> Quand vous cachez des relations, utilisez le nom de la <strong>méthode</strong> de la relation, pas le nom d'accession dynamique.</p>
</blockquote>

<p>Alternativement, vous pouvez utiliser la propriété <code>visible</code> pour définir une liste blanche :</p>

<pre><code>protected $visible = array('first_name', 'last_name');
</code></pre>

<p><a name="array-appends"></a>
Occassionnellement, vous pouvez avoir besoin d'ajouter un tableau d'attributs qui ne correspondent pas à un colonne dans votre base de données. Pour ce faire, vous devez simplement définir un accesseur pour la valeur :</p>

<pre><code>public function getIsAdminAttribute()
{
    return $this-&gt;attributes['admin'] == 'yes';
}
</code></pre>

<p>Une fois que vous avez créé l'accesseur, ajoutez la valeur de la propriété <code>appends</code> au modèle :</p>

<pre><code>protected $appends = array('is_admin');
</code></pre>

<p>Une fois que l'attribut a été ajouté à la list <code>appends</code>, il peut être inclus à la fois sous la modèle tableau ou JSON du modèle.</p>

        <hr />
        <ul class="PrevNextPage">
                            <li class="prev"><a href="queries.html" class="btn-orange">&lArr; Query Builder</a></li>
            
                            <li class="next"><a href="schema.html" class="btn-orange">Le constructeur de schéma &rArr;</a></li>
                    </ul>
    </div>

</div>
    </div><!--/.container-->
    
    <footer>
            </footer>
</body>

<!-- Mirrored from docs.laravel.fr/dev/eloquent by HTTrack Website Copier/3.x [XR&CO'2013], Mon, 03 Mar 2014 17:12:52 GMT -->
</html>

<script src="../js/modernizr.js"></script>
<script src="../js/jquery-2.0.3.min.js"></script>
<script src="../js/app.js"></script>
<script src="../js/prettify/prettify.js"></script>
<script>$("pre").addClass('prettyprint');</script>
<script>prettyPrint();</script>

<script>
$(document).ready(function() {

    $('#doc-versions').hide();
});

    $('.changeVersionLink').click(function() {
        $('#doc-versions').slideToggle();
        $(this).toggleClass('activeChangeVersionLink');
    });
</script>
